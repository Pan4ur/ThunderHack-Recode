package thunder.hack.features.modules.misc;

import meteordevelopment.orbit.EventHandler;
import net.minecraft.client.util.InputUtil;
import net.minecraft.network.packet.c2s.play.PlayerActionC2SPacket;
import net.minecraft.network.packet.s2c.play.BlockUpdateS2CPacket;
import net.minecraft.util.Formatting;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.world.chunk.Chunk;
import thunder.hack.core.Managers;
import thunder.hack.features.cmd.Command;
import thunder.hack.events.impl.PacketEvent;
import thunder.hack.gui.misc.GuiScanner;
import thunder.hack.features.modules.Module;
import thunder.hack.features.modules.render.StorageEsp;
import thunder.hack.gui.notification.Notification;
import thunder.hack.setting.Setting;
import thunder.hack.setting.impl.Bind;
import thunder.hack.utility.Timer;

import java.util.ArrayList;
import java.util.List;

import static thunder.hack.features.modules.client.ClientSettings.isRu;

public class NoCommentExploit extends Module {
    public NoCommentExploit() {
        super("NoCommentExploit", Category.MISC);
    }

    private final Setting<Bind> self = new Setting<>("openGui", new Bind(-1, false, false));
    public Setting<Integer> delay = new Setting<>("Delay", 250, 0, 1000);
    public Setting<Integer> loop = new Setting<>("LoopPerTick", 1, 1, 10);
    public Setting<Boolean> loadgui = new Setting<>("LoadGui", false);

    private static int count, reRunStartX, reRunStartY, currentX, currentZ;
    public static List<Dot> dots = new ArrayList<>();
    private static BlockPos playerPos = null;
    private GuiScanner gui = new GuiScanner();
    private Timer delayTimer = new Timer();
    public static int scannedChunks = 0;
    public int couti = 1;

    public void rerun(int x, int y) {
        dots.clear();
        playerPos = null;
        count = 0;
        delayTimer.reset();
        reRunStartX = x;
        reRunStartY = y;
    }

    @Override
    public void onUpdate() {
        if (InputUtil.isKeyPressed(mc.getWindow().getHandle(), self.getValue().getKey())) mc.setScreen(gui);
        if (GuiScanner.neartrack && scannedChunks > 25) scannedChunks = 0;
        if (GuiScanner.neartrack && scannedChunks == 0) doNocom((int) mc.player.getX(), (int) mc.player.getZ());

        if (GuiScanner.neartrack) return;

        if (loadgui.getValue()) {
            mc.setScreen(gui);
            loadgui.setValue(false);
        }

        if (!GuiScanner.busy) doNocom((int) mc.player.getX(), (int) mc.player.getZ());
        else {
            if (reRunStartX != 0 && reRunStartY != 0) {
                doNocom(reRunStartX, reRunStartY);
            }
        }
    }

    public void doNocom(int x3, int y3) {
        playerPos = BlockPos.ofFloored(mc.player.getX(), mc.player.getY() - 1, mc.player.getZ());

        if (delayTimer.passedMs(delay.getValue())) {
            for (int i = 0; i < loop.getValue(); i++) {

                int x1 = getSpiralCoords(count)[0] * 128 + x3;
                int z1 = getSpiralCoords(count)[1] * 128 + y3;

                final BlockPos position = new BlockPos(x1, 0, z1);
                currentX = x1;
                currentZ = z1;
                sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, playerPos, Direction.EAST));
                sendPacket(new PlayerActionC2SPacket(PlayerActionC2SPacket.Action.ABORT_DESTROY_BLOCK, position, Direction.EAST));

                dots.add(new Dot(x1 / 16, z1 / 16, DotType.Searched));
                playerPos = BlockPos.ofFloored(mc.player.getX(), mc.player.getY() - 1, mc.player.getZ());
                delayTimer.reset();
                count++;
                ++scannedChunks;
            }
        }
    }

    @EventHandler
    public final void onPacketReceive(PacketEvent.Receive event) {
        if (event.getPacket() instanceof BlockUpdateS2CPacket packet) {
            final int x = packet.getPos().getX();
            final int z = packet.getPos().getZ();
            for (Chunk chunk : StorageEsp.getLoadedChunks())
                if (chunk.getPos().x == x / 16 || chunk.getPos().z == z / 16) return;
            String shittytext = (isRu() ? "Обнаружен игрок на X: " : "Player spotted at X: ") + Formatting.GREEN + x + Formatting.RESET + " Z: " + Formatting.GREEN + z;
            dots.add(new Dot(x / 16, z / 16, DotType.Spotted));
            Command.sendMessage(shittytext);
            gui.consoleout.add(new Cout(couti, shittytext));
            ++couti;
            if (GuiScanner.track) {
                gui.consoleout.add(new Cout(couti, (isRu() ? "Отслеживаем игроков на X: " : "Tracking players on X: ") + x + " Z: " + z));
                ++couti;
                rerun(x, z);
            }
            Managers.NOTIFICATION.publicity("NoCommentExploit", shittytext, 3, Notification.Type.INFO);
        }
    }

    private int[] getSpiralCoords(int n) {
        int x = 0;
        int z = 0;
        int d = 1;
        int lineNumber = 1;
        int[] coords = {0, 0};
        for (int i = 0; i < n; i++) {
            if (2 * x * d < lineNumber) {
                x += d;
                coords = new int[]{x, z};
            } else if (2 * z * d < lineNumber) {
                z += d;
                coords = new int[]{x, z};
            } else {
                d *= -1;
                lineNumber++;
                n++;
            }
        }
        return coords;
    }

    @Override
    public void onEnable() {
        playerPos = null;
        count = 0;
    }

    @Override
    public void onDisable() {
        dots.clear();
        playerPos = null;
        count = 0;
    }

    @Override
    public String getDisplayInfo() {
        return currentX + " , " + currentZ;
    }

    public enum DotType {
        Spotted, Searched
    }

    public record Cout(int posY, String out) {}
    public record Dot(int posX, int posY, DotType type) {}
}
